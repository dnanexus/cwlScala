package dx.cwl

import dx.cwl.Utils.{translateOptional, translateOptionalArray, translateOptionalObject}
import org.w3id.cwl.cwl1_2.{CWLVersion, LoadListingEnum, SecondaryFileSchemaImpl}

import java.net.URI
import java.nio.file.Path
import scala.util.matching.Regex

/**
  * An identifier of the form [\[namespace]#][frag], where frag is a
  * '/'-delimited string. For frag "foo/bar/baz", parent="foo/bar"
  * and name="baz".
  */
case class Identifier(namespace: Option[String], frag: Option[String]) {
  def fullyQualifiedName: Option[String] = {
    frag.map(n => namespace.map(ns => s"${ns}#${n}").getOrElse(n))
  }

  def parent: Option[String] = {
    frag.flatMap {
      case n if n.contains('/') => Some(n.substring(0, n.lastIndexOf('/')))
      case _                    => None
    }
  }

  def name: Option[String] = {
    frag.map {
      case n if n.contains('/') => n.substring(n.lastIndexOf('/') + 1)
      case n                    => n
    }
  }

  /**
    * Returns an iterator over all ancestor identifers and this identifier. For example, if this identifier has frag
    * A/B/C, then the iterator yields identifiers with fragments [A, A/B, A/B/C].
    */
  def iter: Iterator[Identifier] = {
    if (this.frag.isEmpty) {
      Iterator.empty[Identifier]
    } else {
      val parentIter = this.parent
        .map(parentFrag => Identifier(this.namespace, Some(parentFrag)).iter)
        .getOrElse(Iterator.empty[Identifier])
      parentIter ++ Iterator.fill(1)(this)
    }
  }
}

object Identifier {
  val CwlExtensions = Vector(".cwl", ".cwl.json", ".json")
  val Main = "main"
  val MainFrag = s"#${Main}"
  val ImportNamespaceRegex: Regex = "^(.+\\.(?:cwl|yml|yaml))/(.+)".r

  def fromUri(uri: URI): Identifier = {
    val (namespace, name) = Utils.normalizeAndSplitUri(uri)
    Identifier(namespace, name)
  }

  def fromSource(source: Path, namespace: Option[String]): Identifier = {
    val fileName = source.getFileName.toString
    val name = CwlExtensions
      .collectFirst {
        case ext if fileName.endsWith(ext) => fileName.dropRight(ext.length)
      }
      .getOrElse(fileName)
    Identifier(namespace, Some(name))
  }

  def parse(uri: String,
            stripFragPrefix: Option[String] = None,
            defaultNamespace: Option[String] = None): Identifier = {
    assert(stripFragPrefix.forall(_.endsWith("/")), "stripFragPrefix must end with '/'")
    val (namespace, frag) =
      try {
        Utils.normalizeAndSplitUri(URI.create(uri))
      } catch {
        case _: IllegalArgumentException if uri.startsWith("_:") =>
          // this is a random id generated by the Java parser for an
          // anonymous/inline process
          (None, Some(uri.drop(2)))
        case _: Throwable => Utils.splitUri(uri)
      }
    val (importNamespace, strippedFrag) = (frag, stripFragPrefix) match {
      case (None, _) => (None, None)
      case (Some(f), Some(prefix)) if f.startsWith(prefix) =>
        (None, Some(f.drop(prefix.length)))
      case (Some(ImportNamespaceRegex(importNamespace, f)), _) =>
        // The frag may start with a different prefix, indicating the element was
        // imported from another document - try to parse out that prefix. If the
        // uri is absolute, then prepend the existing namespace.
        (namespace.map(ns => s"${ns}#${importNamespace}").orElse(Some(importNamespace)), Some(f))
      case (Some(f), Some(prefix)) =>
        throw new Exception(s"fragment ${f} does not start with prefix ${prefix}")
      case _ => (None, frag)
    }
    Identifier(importNamespace.orElse(namespace).orElse(defaultNamespace), strippedFrag)
  }

  def get(id: java.util.Optional[String],
          defaultNamespace: Option[String],
          defaultFrag: Option[String] = None,
          source: Option[Path] = None,
          stripFragPrefix: Option[String] = None): Option[Identifier] = {
    translateOptional(id).map(Identifier.parse(_, stripFragPrefix, defaultNamespace)) match {
      case Some(id) if id.frag.isDefined => Some(id)
      case id if defaultFrag.isDefined =>
        id.map(_.copy(frag = defaultFrag))
          .orElse(Some(Identifier(namespace = None, frag = defaultFrag)))
      case id if source.isDefined =>
        Some(fromSource(source.get, id.flatMap(_.namespace)))
      case _ => None
    }
  }
}

object Document {
  type Document = Map[Identifier, Process]
  val empty: Document = Map.empty[Identifier, Process]

  implicit class DocumentAdder(doc: Document) {
    def addProcess(proc: Process): Document = {
      val id = proc.id
        .getOrElse(
            throw new Exception(s"process ${proc} has no ID")
        )
      if (doc.contains(id)) {
        throw new Exception(s"two processes have the same ID ${id}")
      }
      doc + (id -> proc)
    }
  }

  implicit class DocumentLookup(doc: Document) {
    def lookup[T <: Identifiable](id: Identifier): T = {}
  }
}

trait Identifiable {
  val id: Option[Identifier]

  def getName: Option[String] = id.flatMap(_.frag)

  def hasName: Boolean = getName.isDefined

  def frag: String = id.flatMap(_.frag).getOrElse(throw new Exception(s"${this} has no name"))

  def parent: Option[String] = {
    if (hasName) {
      id.flatMap(_.parent)
    } else {
      throw new Exception(s"${this} has no name")
    }
  }

  def name: String =
    id.flatMap(_.name).getOrElse(throw new Exception(s"${this} has no name"))
}

trait Meta extends Identifiable {
  val label: Option[String]
  val doc: Option[String]
}

trait Loadable {
  val loadContents: Boolean
  val loadListing: LoadListing.LoadListing
}

trait Parameter extends Meta {
  val cwlType: CwlType
  val secondaryFiles: Vector[SecondaryFile]
  val streamable: Boolean
}

trait InputParameter extends Parameter with Loadable {
  val default: Option[CwlValue]
  val format: Vector[CwlValue]
}

trait OutputParameter extends Parameter {
  val format: Option[CwlValue]
}

/**
  * Marker trait for top-level elements (CommandLineTool, Workflow, ExpressionTool, etc)
  */
trait Process extends Meta {
  val source: Option[String]
  val cwlVersion: Option[CWLVersion]
  val label: Option[String]
  val doc: Option[String]
  val intent: Vector[String]
  val inputs: Vector[InputParameter]
  val outputs: Vector[OutputParameter]
  val requirements: Vector[Requirement]
  val hints: Vector[Hint]
}

// https://www.commonwl.org/v1.2/CommandLineTool.html#SecondaryFileSchema
case class SecondaryFile(pattern: CwlValue, required: CwlValue)

object SecondaryFile {
  def apply(secondaryFile: SecondaryFileSchemaImpl,
            schemaDefs: Map[String, CwlSchema],
            isInput: Boolean): SecondaryFile = {
    val required = translateOptionalObject(secondaryFile.getRequired)
      .map(CwlValue(_, schemaDefs))
      .getOrElse(BooleanValue(isInput))
    SecondaryFile(CwlValue(secondaryFile.getPattern, schemaDefs), required)
  }

  def applyArray(secondaryFiles: java.lang.Object,
                 schemaDefs: Map[String, CwlSchema],
                 isInput: Boolean): Vector[SecondaryFile] = {
    translateOptionalArray(secondaryFiles).map {
      case sf: SecondaryFileSchemaImpl => SecondaryFile(sf, schemaDefs, isInput)
      case other =>
        throw new RuntimeException(s"unexpected SecondaryFile value ${other}")
    }
  }
}

// https://www.commonwl.org/v1.2/CommandLineTool.html#LoadListingEnum
object LoadListing extends Enumeration {
  type LoadListing = Value
  val No, Shallow, Deep = Value

  def from(loadListing: LoadListingEnum): LoadListing = {
    loadListing match {
      case LoadListingEnum.NO_LISTING      => No
      case LoadListingEnum.SHALLOW_LISTING => Shallow
      case LoadListingEnum.DEEP_LISTING    => Deep
    }
  }
}
