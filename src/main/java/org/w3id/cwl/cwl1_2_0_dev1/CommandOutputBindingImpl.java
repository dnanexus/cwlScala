package org.w3id.cwl.cwl1_2_0_dev1;

import org.w3id.cwl.cwl1_2_0_dev1.utils.LoaderInstances;
import org.w3id.cwl.cwl1_2_0_dev1.utils.LoadingOptions;
import org.w3id.cwl.cwl1_2_0_dev1.utils.LoadingOptionsBuilder;
import org.w3id.cwl.cwl1_2_0_dev1.utils.SavableImpl;
import org.w3id.cwl.cwl1_2_0_dev1.utils.ValidationException;

/**
 * Auto-generated class implementation for <I>https://w3id.org/cwl/cwl#CommandOutputBinding</I><br>
 *
 * <BLOCKQUOTE>
 *
 * Describes how to generate an output parameter based on the files produced by a CommandLineTool.
 *
 * <p>The output parameter value is generated by applying these operations in the following order:
 *
 * <p>- glob - loadContents - outputEval - secondaryFiles
 *
 * </BLOCKQUOTE>
 */
public class CommandOutputBindingImpl extends SavableImpl implements CommandOutputBinding {
  private LoadingOptions loadingOptions_ = new LoadingOptionsBuilder().build();
  private java.util.Map<String, Object> extensionFields_ = new java.util.HashMap<String, Object>();

  private java.util.Optional<Boolean> loadContents;

  /**
   * Getter for property <I>https://w3id.org/cwl/cwl#LoadContents/loadContents</I><br>
   *
   * <BLOCKQUOTE>
   *
   * Only valid when `type: File` or is an array of `items: File`.
   *
   * <p>Read up to the first 64 KiB of text from the file and place it in the "contents" field of
   * the file object for use by expressions. *
   *
   * </BLOCKQUOTE>
   */
  public java.util.Optional<Boolean> getLoadContents() {
    return this.loadContents;
  }

  private java.util.Optional<LoadListingEnum> loadListing;

  /**
   * Getter for property <I>https://w3id.org/cwl/cwl#LoadContents/loadListing</I><br>
   *
   * <BLOCKQUOTE>
   *
   * Only valid when `type: Directory` or is an array of `items: Directory`.
   *
   * <p>Specify the desired behavior for loading the `listing` field of a Directory object for use
   * by expressions.
   *
   * <p>The order of precedence for loadListing is:
   *
   * <p>1. `loadListing` on an individual parameter 2. Inherited from `LoadListingRequirement` 3. By
   * default: `no_listing` *
   *
   * </BLOCKQUOTE>
   */
  public java.util.Optional<LoadListingEnum> getLoadListing() {
    return this.loadListing;
  }

  private Object glob;

  /**
   * Getter for property <I>https://w3id.org/cwl/cwl#CommandOutputBinding/glob</I><br>
   *
   * <BLOCKQUOTE>
   *
   * Find files or directories relative to the output directory, using POSIX glob(3) pathname
   * matching. If an array is provided, find files or directories that match any pattern in the
   * array. If an expression is provided, the expression must return a string or an array of
   * strings, which will then be evaluated as one or more glob patterns. Must only match and return
   * files/directories which actually exist.
   *
   * <p>If the value of glob is a relative path pattern (does not begin with a slash '/') then it is
   * resolved relative to the output directory. If the value of the glob is an absolute path pattern
   * (it does begin with a slash '/') then it must refer to a path within the output directory. It
   * is an error if any glob resolves to a path outside the output directory. Specifically this
   * means globs that resolve to paths outside the output directory are illegal.
   *
   * <p>A glob may match a path within the output directory which is actually a symlink to another
   * file. In this case, the expected behavior is for the resulting File/Directory object to take
   * the `basename` (and corresponding `nameroot` and `nameext`) of the symlink. The `location` of
   * the File/Directory is implementation dependent, but logically the File/Directory should have
   * the same content as the symlink target. Platforms may stage output files/directories to cloud
   * storage that lack the concept of a symlink. In this case file content and directories may be
   * duplicated, or (to avoid duplication) the File/Directory `location` may refer to the symlink
   * target.
   *
   * <p>It is an error if a symlink in the output directory (or any symlink in a chain of links)
   * refers to any file or directory that is not under an input or output directory.
   *
   * <p>Implementations may shut down a container before globbing output, so globs and expressions
   * must not assume access to the container filesystem except for declared input and output. *
   *
   * </BLOCKQUOTE>
   */
  public Object getGlob() {
    return this.glob;
  }

  private java.util.Optional<Expression> outputEval;

  /**
   * Getter for property <I>https://w3id.org/cwl/cwl#CommandOutputBinding/outputEval</I><br>
   *
   * <BLOCKQUOTE>
   *
   * Evaluate an expression to generate the output value. If `glob` was specified, the value of
   * `self` must be an array containing file objects that were matched. If no files were matched,
   * `self` must be a zero length array; if a single file was matched, the value of `self` is an
   * array of a single element. Additionally, if `loadContents` is `true`, the File objects must
   * include up to the first 64 KiB of file contents in the `contents` field. The exit code of the
   * process is available in the expression as `runtime.exitCode`. *
   *
   * </BLOCKQUOTE>
   */
  public java.util.Optional<Expression> getOutputEval() {
    return this.outputEval;
  }

  /**
   * Used by {@link org.w3id.cwl.cwl1_2_0_dev1.utils.RootLoader} to construct instances of
   * CommandOutputBindingImpl.
   *
   * @param __doc_ Document fragment to load this record object from (presumably a {@link
   *     java.util.Map}).
   * @param __baseUri_ Base URI to generate child document IDs against.
   * @param __loadingOptions Context for loading URIs and populating objects.
   * @param __docRoot_ ID at this position in the document (if available) (maybe?)
   * @throws ValidationException If the document fragment is not a {@link java.util.Map} or
   *     validation of fields fails.
   */
  public CommandOutputBindingImpl(
      final Object __doc_,
      final String __baseUri_,
      LoadingOptions __loadingOptions,
      final String __docRoot_) {
    super(__doc_, __baseUri_, __loadingOptions, __docRoot_);
    // Prefix plumbing variables with '__' to reduce likelihood of collision with
    // generated names.
    String __baseUri = __baseUri_;
    String __docRoot = __docRoot_;
    if (!(__doc_ instanceof java.util.Map)) {
      throw new ValidationException("CommandOutputBindingImpl called on non-map");
    }
    final java.util.Map<String, Object> __doc = (java.util.Map<String, Object>) __doc_;
    final java.util.List<ValidationException> __errors =
        new java.util.ArrayList<ValidationException>();
    if (__loadingOptions != null) {
      this.loadingOptions_ = __loadingOptions;
    }
    java.util.Optional<Boolean> loadContents;

    if (__doc.containsKey("loadContents")) {
      try {
        loadContents =
            LoaderInstances.optional_BooleanInstance.loadField(
                __doc.get("loadContents"), __baseUri, __loadingOptions);
      } catch (ValidationException e) {
        loadContents = null; // won't be used but prevents compiler from complaining.
        final String __message = "the `loadContents` field is not valid because:";
        __errors.add(new ValidationException(__message, e));
      }

    } else {
      loadContents = null;
    }
    java.util.Optional<LoadListingEnum> loadListing;

    if (__doc.containsKey("loadListing")) {
      try {
        loadListing =
            LoaderInstances.optional_LoadListingEnum.loadField(
                __doc.get("loadListing"), __baseUri, __loadingOptions);
      } catch (ValidationException e) {
        loadListing = null; // won't be used but prevents compiler from complaining.
        final String __message = "the `loadListing` field is not valid because:";
        __errors.add(new ValidationException(__message, e));
      }

    } else {
      loadListing = null;
    }
    Object glob;

    if (__doc.containsKey("glob")) {
      try {
        glob =
            LoaderInstances
                .union_of_NullInstance_or_StringInstance_or_Expression_or_array_of_StringInstance
                .loadField(__doc.get("glob"), __baseUri, __loadingOptions);
      } catch (ValidationException e) {
        glob = null; // won't be used but prevents compiler from complaining.
        final String __message = "the `glob` field is not valid because:";
        __errors.add(new ValidationException(__message, e));
      }

    } else {
      glob = null;
    }
    java.util.Optional<Expression> outputEval;

    if (__doc.containsKey("outputEval")) {
      try {
        outputEval =
            LoaderInstances.optional_Expression.loadField(
                __doc.get("outputEval"), __baseUri, __loadingOptions);
      } catch (ValidationException e) {
        outputEval = null; // won't be used but prevents compiler from complaining.
        final String __message = "the `outputEval` field is not valid because:";
        __errors.add(new ValidationException(__message, e));
      }

    } else {
      outputEval = null;
    }
    if (!__errors.isEmpty()) {
      throw new ValidationException("Trying 'RecordField'", __errors);
    }
    this.loadContents = (java.util.Optional<Boolean>) loadContents;
    this.loadListing = (java.util.Optional<LoadListingEnum>) loadListing;
    this.glob = (Object) glob;
    this.outputEval = (java.util.Optional<Expression>) outputEval;
  }
}
